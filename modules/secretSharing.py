#!/usr/bin/python

#############################################################
# CSE 539 (Applied Cryptography) Fall 2015 - Project        #
# Team: Saurabh Gupta, Omkar Kaptan                         #
# Instructor: Dr. Rida Bazzi                                #
#############################################################

"""Provides a socket wrapper module for communication involving
arbitrary length messages.

Class mysocket
~~~~~~~~~~~~~~
    Attributes: 
        sock
    Constructor: 
        __init__(self, sock=None)
    Methods:
        bind(self, (host, port))
        connect(self, (host, port))
        getportnumber(self)
        accept(self)
        close(self)
        listen(self, backlog)
        send(self, msg, separator)
        recv(self, buffer, separator)
    Static Methods: 
        gethostname()
"""

#################### Import modules #########################
from util import genRandNum, message

#################### Module Metadata ########################
__author__ = "Saurabh Gupta, Omkar Kaptan"
__email__ = "saurabhgupta@asu.edu, okaptan@asu.edu"
__license__ = "GPL"
__version__ = "1.0"

########### Global Variables for Verification Modes #########
NO_VERIFICATION = 1
AUX_INFO_VERIFICATION = 2
MAC_VERIFICATION = 3

#############################################################
#                    Class: secretSharing                   #
#############################################################

class secretSharing:
    """A class of static methods for secret sharing related operations."""

    @staticmethod
    def extendedGCD(a, b):
        """Recursively calculates and returns the extended Euclidean GCD 
        of the given values of a and b.

        Validates the types of a and b to be integers. Recursively calculates 
        the extended Euclidean GCD using ax + by = g equation and returns the 
        tuple (g, x, y).

        Args:
            a: An integer specifying the first number for GCD calculation.
            b: An integer specifying the second number for GCD calculation.

        Returns:
            A tuple (g, x, y) where g, x and y are integers such that they
            satisfy the equation ax + by = g

        Raises:
            TypeError: Error when either a or b is not an integer value. 
        """

        if type(a) not in [int, long]:
            raise TypeError("invalid a: int or long expected")
        elif type(b) not in [int, long]:
            raise TypeError("invalid b: int or long expected")

        if a == 0:
            return (b, 0, 1)
        else:
            g, y, x = secretSharing.extendedGCD(b % a, a)
            return (g, x - (b // a) * y, y)

    @staticmethod
    def modularInverse(num, prime):
        """Calculates the modular inverse using extended Euclidean GCD method for 
        the given num using the given prime as the order of modulo operations.

        Args:
            num: An integer value for which modular inverse is to be calculated.
            prime: An integer value to be used as the order of modulo operations.

        Returns:
            An integer value representing the modular inverse of the given num.

        Raises:
            TypeError: Error when either num or prime is not an integer.
        """     

        if type(num) not in [int, long]:
            raise TypeError("invalid num: int or long expected")
        elif type(prime) not in [int, long]:
            raise TypeError("invalid prime: int or long expected")
        
        num = num % prime
        if num < 0:
            r = secretSharing.extendedGCD(prime, -num)[2]
        else:
            r = secretSharing.extendedGCD(prime, num)[2]
        return (prime + r) % prime


    @staticmethod
    def evaluatePolynomial(msgNum, coefficients, n, prime):
        """Generates shares of the integer msgNum by evaluating the polynomial 
        y = msgNum + c[0]*x + c[1]*x^2 + ... + c[n-2]*x^(n-1) using the list 
        coefficients as the list of c[i] values for n different values of x and 
        returns a list of n pairs [x, y]. The prime value is used as the order 
        of modulo operations is all the evaluations.

        Args:
            msgNum: An integer value specifying the message for which the shares 
                are to be generated.
            coefficients: A list if integer values to be used as coefficients in 
                the polynomial evaluation.
            n: An integer value representing the number of shares to be generated.
            prime: An integer value to be used as the order of modulo operations.

        Returns:
            A list of n shares of the form [x, y] generated by polynomial 
            evaluations for different values of x.

        Raises:
            TypeError: Error when either num, n or prime is not an integer, or 
                when coefficients is not a list of integers.
        """ 

        if type(msgNum) not in [int, long]:
            raise TypeError("invalid msg: int or long expected")
        elif type(n) not in [int, long]:
            raise TypeError("invalid n: int or long expected")
        elif type(prime) not in [int, long]:
            raise TypeError("invalid prime: int or long expected")
        elif type(coefficients) != list:
            raise TypeError("invalid coefficients: list expected")
        else:
            for coeff in coefficients:
                if type(coeff) not in [int, long]:
                    raise TypeError("invalid coefficients: list of int or long expected")
        
        shares = []
        for x in range(1, n+1):
            y = msgNum
            for i in range(1, len(coefficients) + 1):
                exp = (x ** i) % prime
                term = (exp * coefficients[i-1]) % prime
                y = (y + term) % prime
            
            shares.append([x, y])
        
        return shares

    @staticmethod
    def randomPolynomial(k, prime):
        """Generates a random polynomial y = msgNum + c[0]*x + c[1]*x^2 + ... 
        + c[k-2]*x^(k-1) by generating the list of cryptographically secure 
        coefficients c[i] using prime as the order of modulo operations.

        Args:
            k: An integer value representing the number of coefficients to be 
                generated.
            prime: An integer value to be used as the order of modulo operations.

        Returns:
            A list of k-1 randomly generated coefficients for the polynomial 
            y = msgNum + c[0]*x + c[1]*x^2 + ... + c[k-2]*x^(k-1) 

        Raises:
            TypeError: Error when either k or prime is not an integer.
        """

        if type(k) not in [int, long]:
            raise TypeError("invalid k: int or long expected")
        elif type(prime) not in [int, long]:
            raise TypeError("invalid prime: int or long expected")

        coefficients = []
        for i in range(1, k):
            coefficients.append(genRandNum(prime))  
        
        return coefficients 

    @staticmethod
    def generateShares(msg, n, k, prime):
        """Generates n shares for the msg such that any k shares can be used 
        for reconstructing the msg. The prime value is used as the order of 
        modulo operations.

        Args:
            msg: A string message for which the shares are to be generated.
            n: An integer value representing the number of shares to be generated.
            k: An integer value representing the number of shares that are 
                required for reconstructing the msg.
            prime: An integer value to be used as the order of modulo operations.

        Returns:
            A list of n shares of the form [x, y] generated by the 
            evaluatePolynomial method.

        Raises:
            TypeError: Error when either n, k or prime is not an integer, or 
                when msg is not a string.
            ValueError: Error when n and k do not satisfy n > k > 1.
        """

        if type(n) not in [int, long]:
            raise TypeError("invalid n: int or long expected")
        elif type(k) not in [int, long]:
            raise TypeError("invalid k: int or long expected")
        elif n < 2 or k < 2:
            raise ValueError("invalid n or k: value greater than or equal to 2 expected")
        elif n < k:
            raise ValueError("invalid k: value less than or equal to n expected")
        elif type(prime) not in [int, long]:
            raise TypeError("invalid prime: int or long expected")

        if type(msg) == str:
            msgNum = message.strToNum(msg)
        else:
            raise TypeError("invalid msg: str expected")

        coefficients = secretSharing.randomPolynomial(k, prime)
        shares = secretSharing.evaluatePolynomial(msgNum, coefficients, n, prime)
        return shares

    @staticmethod
    def reconstructSecret(shares, k, prime):
        """Reconstruct secret message using 

        Args:
            msg: A string message for which the shares are to be generated.
            n: An integer value representing the number of shares to be generated.
            k: An integer value representing the number of shares that are 
                required for reconstructing the msg.
            prime: An integer value to be used as the order of modulo operations.

        Returns:
            A list of n shares of the form [x, y] generated by the 
            evaluatePolynomial method.

        Raises:
            TypeError: Error when either k or prime is not an integer, or when 
                shares is not a list of [int, int] lists.
            ValueError: Error when k < 2 or when number of shares is less than k.
        """

        if type(shares) != list:
            raise TypeError("invalid shares: list expected")
        elif type(k) not in [int, long]:
            raise TypeError("invalid k: int or long expected")
        elif k < 2:
            raise ValueError("invalid k: value greater than 1 expected")
        elif type(prime) not in [int, long]:
            raise TypeError("invalid prime: int or long expected")
        elif k > len(shares):
            raise ValueError("insufficient number of shares: expected k or more")

        if len(shares) > k:
            shares = shares[:k]

        try:
            xList, yList = zip(*shares)
        except TypeError:
            raise TypeError("invalid shares: list of lists expected")

        secret = 0

        try:
            for [xi, yi] in shares:
                numerator, denominator = 1, 1

                for xj in xList:
                    if xi != xj:
                        numerator = (numerator * -xj) % prime
                        denominator = (denominator * (xi - xj)) % prime

                term = numerator * secretSharing.modularInverse(denominator, prime)
                secret = (secret + prime + (yi * term)) % prime
        except [ValueError, TypeError]:
            raise TypeError("invalid shares: list of [int, int] lists expected")

        return secret

##################### End of Code ###########################